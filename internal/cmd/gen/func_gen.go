package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"text/template"
)

type (
	paramType struct {
		Name string
	}

	sig struct {
		TypeName string
		Params   []param
		FuncName string
	}

	param struct {
		Name string
		Type paramType
	}

	// a group of the same type
	paramGroup struct {
		Names []string
		Type  paramType
	}
)

var (
	stringParamType = paramType{
		Name: "string",
	}

	tmpl = template.Must(template.New("").Parse(`
// generate handler wrappers which avoid allocs
// do not edit this file!
package rte

import (
	"net/http"
)

{{ range $sig := .Sigs }}
func {{ $sig.FuncName }}(method, path string, f func(w http.ResponseWriter, r *http.Request {{- range $g := $sig.ParamGroups }}{{- range $p := $g.Names -}}, {{ $p }}{{- end }} {{$g.Type.Name}}{{end}})) Route {
	return Wrap(method, path, {{ $sig.TypeName }}(f))
}

type {{ $sig.TypeName }} func(w http.ResponseWriter, r *http.Request{{- range $g := $sig.ParamGroups }}{{- range $p := $g.Names -}}, {{ $p }}{{- end }} {{$g.Type.Name}}{{end}})

func (f {{ $sig.TypeName }}) Wrap(segIdxes []int) (http.HandlerFunc, error) {
	if len(segIdxes) != {{ len $sig.Params }} {
		return nil, WrongNumParams
	}

	return func(w http.ResponseWriter, r *http.Request) {
		var segs [{{ len $sig.Params }}]string
		findNSegments(r.URL.Path, segIdxes[:], segs[:])
		f(w, r{{- range $idx, $_ := $sig.Params -}}, segs[{{ $idx }}]{{- end }})
	}, nil
}
{{ end }}
`))
)

func (s sig) ParamGroups() []paramGroup {
	var grps []paramGroup
	var cur paramGroup
	for _, p := range s.Params {
		if cur.Type.Name == "" {
			cur.Type = p.Type
		}

		if cur.Type != p.Type {
			grps = append(grps, cur)
			cur = paramGroup{Type: p.Type}
		}

		cur.Names = append(cur.Names, p.Name)
	}
	return append(grps, cur)
}

func main() {
	var sigs []sig
	for i := 0; i < 5; i++ {
		nargs := i + 1
		s := sig{
			FuncName: fmt.Sprintf("Func%d", nargs),
			TypeName: fmt.Sprintf("func%d", nargs),
		}
		for j := 0; j < nargs; j++ {
			s.Params = append(s.Params, param{
				Name: fmt.Sprintf("p%d", j),
				Type: stringParamType,
			})
		}
		sigs = append(sigs, s)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, struct{ Sigs []sig }{sigs}); err != nil {
		log.Fatalf("tmpl.Execute: %v", err)
	}

	bs, err := format.Source(buf.Bytes())
	if err != nil {
		os.Stdout.Write(buf.Bytes())
		log.Fatalf("format.Source: %v", err)
	}

	if _, err := os.Stdout.Write(bs); err != nil {
		log.Fatalf("os.Stdout.Write: %v", err)
	}
}
